/**
 * On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square 
 * represented by 0.
 *
 * A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.
 * 
 * The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].
 *
 * Given a puzzle board, return the least number of moves required so that the state of the board is 
 * solved. If it is impossible for the state of the board to be solved, return -1.
 *
 * Examples:
 * Input: board = [[1,2,3],[4,0,5]]
 * Output: 1
 * Explanation: Swap the 0 and the 5 in one move.
 * 
 * Input: board = [[1,2,3],[5,4,0]]
 * Output: -1
 * Explanation: No number of moves will make the board solved.
 *
 * Input: board = [[4,1,2],[5,0,3]]
 * Output: 5
 * Explanation: 5 is the smallest number of moves that solves the board.
 * An example path:
 * After move 0: [[4,1,2],[5,0,3]]
 * After move 1: [[4,1,2],[0,5,3]]
 * After move 2: [[0,1,2],[4,5,3]]
 * After move 3: [[1,0,2],[4,5,3]]
 * After move 4: [[1,2,0],[4,5,3]]
 * After move 5: [[1,2,3],[4,5,0]]
 *
 * Input: board = [[3,2,4],[1,5,0]]
 * Output: 14
 *
 * Note:
 * board will be a 2 x 3 array as described above.
 * board[i][j] will be a permutation of [0, 1, 2, 3, 4, 5].
 */
 
// Approach #1: BFS.
class Solution {
    int[] dx = {1, -1, 0, 0};
    int[] dy = {0, 0, 1, -1};
    
    public int slidingPuzzle(int[][] board) {
        Map<String, Integer> cache = new HashMap<>();
        Queue<int[][]> queue = new LinkedList<>();
        cache.put(Arrays.deepToString(board), 0);
        queue.offer(board);
        while (!queue.isEmpty()) {
            int[][] cur = queue.poll();
            int prev = cache.get(Arrays.deepToString(cur));
            if (check(cur)) return prev;
            for (int i = 0; i < 2; ++ i) {
                for (int j = 0; j < 3; ++ j) {
                    if (cur[i][j] == 0) continue;
                    for (int k = 0; k < 4; ++ k) {
                        if (i + dx[k] >= 0 && i + dx[k] < 2 
                            && j + dy[k] >= 0 && j + dy[k] < 3
                            && cur[i + dx[k]][j + dy[k]] == 0) {
                            int[][] tmp = deepCopy(cur);
                            tmp[i + dx[k]][j + dy[k]] = cur[i][j];
                            tmp[i][j] = 0;
                            if (!cache.containsKey(Arrays.deepToString(tmp))) {
                                cache.put(Arrays.deepToString(tmp), prev + 1);
                                queue.offer(tmp);
                            }
                        }
                    }
                }
            }
        }
        return -1;
    }
    
    private int[][] deepCopy(int[][] source) {
        int m = source.length, n = source[0].length;
        int[][] dest = new int[m][n];
        for (int i = 0; i < m; ++ i) {
            for (int j = 0; j < n; ++ j) {
                dest[i][j] = source[i][j];
            }
        }
        return dest;
    }
    
    private boolean check(int[][] board) {
        for (int i = 0; i < 2; ++ i) {
            for (int j = 0; j < 3; ++ j) {
                if (board[i][j] != (i * 3 + j + 1) % 6) return false;
            }
        }
        return true;
    }
}
