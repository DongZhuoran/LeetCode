/**
 * Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and
 * end with a special character '#'). For each character they type except '#', you need to return the top 3
 * historical hot sentences that have prefix the same as the part of sentence already typed. Here are the 
 * specific rules:
 *
 * 1. The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.
 * 2. The returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several 
 *    sentences have the same degree of hot, you need to use ASCII-code order (smaller one appears first).
 * 3. If less than 3 hot sentences exist, then just return as many as you can.
 * 4. When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.
 *
 * Your job is to implement the following functions:
 * 1. The constructor function:
 *    AutocompleteSystem(String[] sentences, int[] times): This is the constructor. The input is historical data. 
 *    Sentences is a string array consists of previously typed sentences. Times is the corresponding times a
 *    sentence has been typed. Your system should record these historical data.
 * 2. Now, the user wants to input a new sentence. The following function will provide the next character the user types:
 *    List<String> input(char c): The input c is the next character typed by the user. The character will only be lower-case letters ('a' to 'z'), blank space (' ') or a special character ('#'). Also, the previously typed sentence should be recorded in your system. The output will be the top 3 historical hot sentences that have prefix the same as the part of sentence already typed.
 *
 * Example:
 * Operation: AutocompleteSystem(["i love you", "island","ironman", "i love leetcode"], [5,3,2,2]) 
 * The system have already tracked down the following sentences and their corresponding times: 
 * "i love you" : 5 times 
 * "island" : 3 times 
 * "ironman" : 2 times 
 * "i love leetcode" : 2 times 
 * 
 * Now, the user begins another search: 
 * Operation: input('i') 
 * Output: ["i love you", "island","i love leetcode"] 
 * Explanation: 
 * There are four sentences that have prefix "i". Among them, "ironman" and "i love leetcode" have same hot 
 * degree. Since ' ' has ASCII code 32 and 'r' has ASCII code 114, "i love leetcode" should be in front of 
 * "ironman". Also we only need to output top 3 hot sentences, so "ironman" will be ignored. 
 *
 * Operation: input(' ') 
 * Output: ["i love you","i love leetcode"] 
 * Explanation: 
 * There are only two sentences that have prefix "i ". 
 *
 * Operation: input('a') 
 * Output: [] 
 * Explanation: 
 * There are no sentences that have prefix "i a". 
 *
 * Operation: input('#') 
 * Output: [] 
 * Explanation: 
 * The user finished the input, the sentence "i a" should be saved as a historical sentence in system. And 
 * the following input will be counted as a new search. 
 *
 * Note:
 * 1. The input sentence will always start with a letter and end with '#', and only one blank space will exist 
 *    between two words.
 * 2. The number of complete sentences that to be searched won't exceed 100. The length of each sentence including
 *    those in the historical data won't exceed 100.
 * 3. Please use double-quote instead of single-quote when you write test cases even for a character input.
 * 4. Please remember to RESET your class variables declared in class AutocompleteSystem, as static/class 
 *    variables are persisted across multiple test cases. Please see here (https://leetcode.com/faq/#different-output) 
 *    for more details.
 */

// Approach #1: Prefix hash. Time complexity of constructor is O(n), and that of input operation is O(nk), where n is 
//              the number of historical sentences and k is the size of current input.
class AutocompleteSystem {
    private static StringBuilder curInput = new StringBuilder();
    private Map<String, Integer> sentenceMap;
    
    public AutocompleteSystem(String[] sentences, int[] times) {
        this.curInput = new StringBuilder();
        this.sentenceMap = new HashMap<>();
        for (int i = 0; i < sentences.length; ++i) {
            sentenceMap.put(sentences[i], times[i]);
        }
    }
    
    public List<String> input(char c) {
        if (c == '#') {
            sentenceMap.put(curInput, 1 + sentenceMap.getOrDefault(curInput, 0));
            return new ArrayList<>();
        } else {
            curInput.append(c);
        }
        
        int size = 0;
        int minHot = -1;
        String minSentence = "";
        List<String> res = new ArrayList<>();
        for (String sentence: sentenceMap.keySet()) {
            if (sentence.startsWith(curInput.toString())) {
                if (size < 3) {
                    res.add(sentence);
                    size++;
                    if (minHot == -1 || minHot > sentenceMap.get(sentence) ||
                                    minHot == sentenceMap.get(sentence) && minSentence.compareTo(sentence) < 0) {
                        minHot = sentenceMap.get(sentence);
                        minSentence = sentence;
                    }
                } else {
                    if (sentenceMap.get(sentence) > minHot || 
                                    sentenceMap.get(sentence) == minHot && sentence.compareTo(minSentence) < 0) {
                        res.remove(minSentence);
                        res.add(sentence);
                        minHot = -1;
                        for (Sting s: res) {
                            if (minHot == -1 || minHot > sentenceMap.get(s) || 
                                    minHot == sentenceMap.get(s) && minSentence.compareTo(s) < 0) {
                                minHot = sentenceMap.get(s);
                                minSentence = s;
                            }
                        }
                    }
                }
            }
        }
        // Sort res according to hot rates.
        for (int i = res.size(); i > 0; --i) {
            for (int j = 0; j < i - 1; ++j) {
                if (sentenceMap.get(res.get(j)) < sentenceMap.get(res.get(j + 1))) {
                    String tmp = res.get(j);
                    res.get(j) = res.get(j + 1);
                    res.get(j + 1) = tmp;
                }
            }
        }
        // The above part can be optimized by PriorityQueue.
        return res;
    }
}

// Approach #2: trie.
class AutocompleteSystem {
    private static StringBuilder curInput = new StringBuilder();
    private TrieNode root;
    
    public AutocompleteSystem(String[] sentences, int[] times) {
        this.curInput = new StringBuilder();
        // Create a trie.
        for (int i = 0; i < sentences.length; ++i) {
            insert(sentences[i], times[i]);
        }
    }
    
    public List<String> input(char c) {
        if (c == '#') {
            // TODO: update historical sentences and times correspondingly.
            return new ArrayList<>();
        } else {
            curInput.append(c);
        }
        
        Map<String, Integer> resMap = search(curInput);
        return getTop3(resMap);
    }
    
    private List<String> getTop3(Map<String, Integer> resMap) {
        List<String> res = new ArrayList<>();
        // ...
    }
    
    private void insert(String sentence, int time) {
        TrieNode cur = root;
        for (int i = 0; i < sentence.length(); ++i) {
            if (!cur.children.containsKey(sentence.charAt(i))) {
                cur.children.put(sentence.charAt(i), new TrieNode());
            }
            cur = cur.children.get(sentence.charAt(i));
        }
        cur.hot = time;
    }
    
    private Map<String, Integer> search(String curString) {
        TrieNode cur = root;
        for (int i = 0; i < curString.length(); ++i) {
            if (!cur.children.containsKey(curString.charAt(i))) {
                return null;
            }
        }
        Map<String, Integer> res = new HashMap<>();
        StringBuilder sentence = new StringBuilder();
        search_helper(cur, res, sentence);
        return res;
    }
    
    private void search_helper(TrieNode node, Map<String, Integer> res, StringBuilder sentence) {
        TrieNode cur = node;
        if (cur.hot > 0) {
            res.put(sentence, hot);
        }
        if (cur.children.size() == 0) {
            return;
        }
        for (Map.Entry entry: cur.children) {
            sentence.append(entry.getKey());
            search_helper(entry.getValue(), res, sentence);
            sentence.removeCharAt(sentence.size() - 1);
        }
    }
    
    class TrieNode {
        int hot;
        Map<Character, TrieNode> children;
        public TrieNode() {
            hot = 0;
            children = new HashMap<>();
        }
    }
}
