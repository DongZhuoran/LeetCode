/**
 * Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's 
 * (representing land) connected 4-directionally (horizontal or vertical.) You 
 * may assume all four edges of the grid are surrounded by water.
 *
 * Count the number of distinct islands. An island is considered to be the same 
 * as another if and only if one island can be translated (and not rotated or reflected) 
 * to equal the other.
 *
 * Example 1:
 * 11000
 * 11000
 * 00011
 * 00011
 * Given the above grid map, return 1.
 *
 * Example 2:
 * 11011
 * 10000
 * 00001
 * 11011
 * Given the above grid map, return 3.
 * 
 * Notice that:
 * 11
 * 1
 * and
 *
 * 1
 * 11
 * are considered different island shapes, because we do not consider reflection / rotation.
 * 
 * Note: The length of each dimension in the given grid does not exceed 50.
 */

class Solution {
    int[] dirX = {1, -1, 0, 0};
    int[] dirY = {0, 0, 1, -1};
    
    public int numDistinctIslands(int[][] grid) {
        Set<String> res = new HashSet<>();
        int[][] g = grid;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                Set<String> set = new HashSet<>();
                dfs(g, i, j, 0, 0, set);
                res.add(set.toString());
            }
        }
        return res.size();
    }
    
    public void dfs(int[][] g, int i, int j, int idx, int idy, Set<String> set) {
        if (i < 0 || i == g.length || j < 0 || j == g[0].length || g[i][j] == 0) return;
        set.add(idx + "_" + idy);
        g[i][j] = 0;
        for (int k = 0; k < dirX.length; ++k) {
            dfs(g, i + dirX[k], j + dirY[k], idx + dirX[k], idy + dirY[k], set);
        }
    }
}
