/**
 * A chess knight can move as indicated in the chess diagram below:
 * (https://leetcode.com/problems/knight-dialer/)
 * This time, we place our chess knight on any numbered key of a phone pad (indicated above),
 * and the knight makes N-1 hops.  Each hop must be from one key to another numbered key.
 * 
 * Each time it lands on a key (including the initial placement of the knight), it presses 
 * the number of that key, pressing N digits total.
 *
 * How many distinct numbers can you dial in this manner?
 *
 * Since the answer may be large, output the answer modulo 10^9 + 7.
 *
 * Example 1:
 * Input: 1
 * Output: 10
 *
 * Example 2:
 * Input: 2
 * Output: 20
 *
 * Example 3:
 * Input: 3
 * Output: 46
 *
 * Note:
 * 1 <= N <= 5000
 */
 
// Approach #1: DP. Time -> O(N).
class Solution {
    public int knightDialer(int N) {
        if (N <= 0) return 0;
        int mod = 1000000007;
        int[][] moves = new int[][]{
            {4,6},{6,8},{7,9},{4,8},{3,9,0},
            {},{1,7,0},{2,6},{1,3},{2,4}};
        
        int[][] dp = new int[2][10];
        int old = 0, now = 0;
        Arrays.fill(dp[now], 1);
        for (int i = 0; i < N - 1; ++ i) {
            old = now;
            now = 1 - old;
            Arrays.fill(dp[now], 0);
            for (int j = 0; j < 10; ++ j) {
                for (int nei: moves[j]) {
                    dp[now][nei] += dp[old][j];
                    dp[now][nei] %= mod;
                }
            }
        }
        
        long res = 0;
        for (int x: dp[now]) {
            res += x;
        }
        return (int) (res % mod);
    }
}
